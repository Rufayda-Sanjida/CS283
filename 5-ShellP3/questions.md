1. Your shell forks multiple child processes when executing piped commands. How does your implementation ensure that all child processes complete before the shell continues accepting user input? What would happen if you forgot to call waitpid() on all child processes?

I use waitpid() to make sure that every child process is finished. In a loop, this allows the shell to finish all child processes for every forked process. This makes processes run more smoothly and stops zombie processes. Before processing the next important command, the parent shell always wait until all children have been terminated. Zombie processes would accumulate, child processes would keep running, and leaks would be likely since the child processes would be orphaned while the parent process kept calling a new process if waitpid() was not invoked.

2. The dup2() function is used to redirect input and output file descriptors. Explain why it is necessary to close unused pipe ends after calling dup2(). What could go wrong if you leave pipes open?

Unused pipe ends must be closed after invoking dup2 because leaving the original pipe ends open can result in resource leaks and hinder the application's ability to function as intended. If a writer process fails to complete its read end of the pipe and all writer processes terminate, the reader process will never receive an EOF signal since there is still an open write end reference. Also, if a reader fails to close its write end, the pipe remains open for writing, which can potentially result in an infinite block while it awaits new information. 

3. Your shell recognizes built-in commands (cd, exit, dragon). Unlike external commands, built-in commands do not require execvp(). Why is cd implemented as a built-in rather than an external command? What challenges would arise if cd were implemented as an external process?

Because it needs to change the shell process's current working directory, the cd command needs to be incorporated into the shell.  If cd were to be used as an external command: Directory navigation commands are usually implemented as shell built-ins across all shell implementations because the child process would change its own working directory, but this change would not affect the parent shell process. The shell would stay in its original directory after the cd command finished. Environment variables like PWD would not be properly updated in the shell's context, and relative paths in subsequent commands would resolve incorrectly.

4. Currently, your shell supports a fixed number of piped commands (CMD_MAX). How would you modify your implementation to allow an arbitrary number of piped commands while still handling memory allocation efficiently? What trade-offs would you need to consider?

Instead of using fixed arrays to hold command structures, we can use linked lists or dynamic arrays to accommodate arbitrary pipe chains. Therefore, when parsing pipe sequences, the application can allocate memory as needed. Allocating dynamic pipe file descriptors is also essential for effectively managing the command count. The trade offs include that it adds complexity to memory management and error handling, and it may result in memory fragmentation. When you reallocate, it can also result in performance overhead, and you would need to cleanup memory up thorougly to prevent leaks.
